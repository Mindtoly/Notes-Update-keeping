# 命名规范

## 1.文件命名规则

文件名全部小写，可以含下划线或连字符，按项目约定命名,且尽量保证文件名明确。比如：

cmd_save_player_info_class.cc my_use_full_class.cc

定义类的文件名一般是成对出现，如：foo_bar.h foo_bar.cc

若是类中含大量内联函数，我们还可使用-ini.h文件，使之文件内容更加清晰，于是又如：

url_table.h url_table.cc url-table-ini.h

## 2.类命名规则

类型命名每个单词首字母大写，不含下划线，以名词形式。比如： MyPalyerManager，这对于所有类型命名一样，类结构体，枚举，类定义都是如此，比如：MyExcitingEnum

## 3.变量命名规则

变量名一律小写，单词用下划线相连，例如：

int player_id; string table_name;

特殊的是类成员变量，后跟下划线区别普通变量，比如： player_name_ player_id_

全局变量则以 g_ 开头，比如 ： g_system_time

当然结构体成员变量还是和普通变量一样,比如：string name; int num_entries;

## 4.常量命名规则

k面跟大写字母开头的单词，比如：

const int kDaysInAWeek=7;

const string kCompanyName=”Tecent”;

## 5.函数命名规则

常规函数每个单词首字母大写，使用命令式语气，比如：OpenFile() CheckFileName()，

而存取函数或短小的内联函数使用小写加下划线，且与访问变量相吻合，比如 set_num_errors();

```c++
e.g.
class Player{
public:
	void set_player_id(const int player_id){return player_id_=player_id;}
	int get_player_id() const{return player-id_;}
private:
	int palyer_id_;
};
```



## 6.名字空间命名

命名空间全小写，并基于项目名称和目录结构，比如

google_awesome_project

## 7.枚举命名规则

枚举类名属于类型名，按类命名，枚举值全大写加下划线，比如：ENUM_NAME

## 8.宏变量命名规则

如果你一定要用到宏，全大写加下划线，比如：

define PI_ROUND 3.0

------



# 笔记

## iostream标准库

包含**istream** 和 **ostream**两个基础类型，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读入或写入IO设备的。术语“流”*(stream)*想要表达的是，随着时间的推移，字符是顺序生成或消耗的。

标准输入*(standard input)*: **cin** (istream类型对象)

标准输出*(standard output)*: **cout** (ostream类型对象)

标准错误*(strandard error)*: **cerr** (ostream类型对象, 输出警告和错误消息)

**clog** : ostream类型对象, 输出程序运行时的一般性信息。



输出运算符 **<<** 接受两个运算对象，左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。将指定的值写到给定的ostream对象中。计算结果就是左侧运算对象。

输入运算符 **>>** 接受一个istream作为其左侧运算对象，接受一个对象作为其右侧对象。从给定的istream读入数据，并存入给定对象中。返回左侧运算对象作为计算结果。



**endl** 操纵符*(manipulator)* : 将换行符写入输出流，并将与设备关联的缓冲区*(buffer)*的内容刷到设备中，保证目前为止程序所暂存的所有输出都真正写入输出流。



## 命名空间*(namespace)*

作用域运算符 **::** 

```c++
e.g.
std::cout
```





## 注释*(comments)*

**//** 单行注释，以“//”开始，以换行符结束。这种注释可以包含任何文本，包括额外的双斜线。

**/* **& ***/** 界定符对注释。以 “ /* ” 开始，以 “ */ ” 结束，可以包含除 “\*/” 外的任意内容，包含换行符。一个注释不能嵌套在另一个注释之内。





## 控制流

### 语句块*(block)*

语句块就是用花括号包围的零条或多条语句的序列。语句块也是语句的一种，在任何要求使用可以语句块。

### 循环条件*(condition)*是istream对象

```c++
e.g.
while(std::cin >> value)
```

当使用一个istream对象作为条件时，其效果是检测**流** *(stream)* 的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到**文e.g.件结束符** *(end-of-file)* ，或遇到一个无效输入时，istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。



### while 语句

```c++
while (condition)
    statement
```

**while**语句反复执行一段代码*(statement)*，直至给定条件*(condition)*为假为止。



### for 语句

```c++
for(init-statement; condition; expression)
    statement
```

for语句包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个**初始化语句** *(init-statement)*、一个**循环条件** *(condition)* 以及一个**表达式** *(expression)*。

循环体每次执行前都会先检查循环条件*(condition)*，只要条件为真，就会执行循环体*(statement)*，表达式*(expression)*在循环体后执行。一直执行循环直至条件为假。



### if 语句

```c++
if(condition)
    statement
else statement
```

根据一个特定条件的值进行条件执行的语句。如果条件为真，执行 if 语句体。否则，执行else语句体（如果存在的话）。



## 运算符

小于等于运算符 **<=** 

复合赋值运算符 **+=** ,将右侧的运算对象加到左侧运算对象上，将结果保存到左侧运算对象中。

```c++
e.g.
num += val;
//the same as:
num = num + val;
```

**赋值** *(assignment)*

前缀递增运算符 **++**

```c++
e.g.
++n;
```

相等运算符 **==**



## 错误类型

语法错误*(syntax error)*

类型错误*(type error)*

声明错误*(declaration error)*



## 类*(class)*

在C++中，通过定义**类** *(class)* 来定义自己的**数据结构** *(data structure)*。一个类定义一个类型，以及与其关联的一组操作，即**类类型** *(class type)*。

### 成员函数*(member function)*

成员函数是定义为类的一部分的函数，有时也被称为**方法** *(method)*。

### 点运算符 "**.**" 

只能用于类类型的对象，用于访问指定成员。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。 

```c++
iteml.isbn()
// 名为iteml的对象的isbn成员
```

### 调用运算符 "**()**"

用于调用一个函数。调用运算符是一对圆括号，里面放置**实参 *(argument)* 列表** （可能为空）。

```c++
iteml.isbn()
// 调用名为iteml的对象的成员函数isbn
```



## 基本内置类型

C++定义了一套包括**算术类型** *(arithmetic type)* 和**空类型** *(void)* 在内的基本数据类型。

### 算术类型*(arithmetic type)*

分为**整型** *(integral type，包括字符和布尔类型)* 和 **浮点型**。

| 类型        | 含义         | 大小         |
| ----------- | ------------ | ------------ |
| `bool`      | 布尔类型     | 未定义       |
| `char`      | 字符         | 8位          |
| `int`       | 整型         | 16位         |
| `long`      | 长整型       | 32位         |
| `long long` | 长整型       | 64位         |
| `float`     | 单精度浮点数 | 6个有效数字  |
| `double`    | 双精度浮点数 | 10个有效数字 |

**布尔类型** *(bool)* 的取值是真*(true)*或者假*(false)*。

除去布尔型和扩展的字符型之外，其他整型可以划分为**带符号的** *(signed)* 和**无符号的** *(unsigned)* 两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。

**字符型**被分为了三种：**char**、**signed char** 和 **unsigned char**。尽管字符型有三种，但表现形式却只有两种：带符号的和无符号的。具体表现为哪一种由编译器决定。



### 如何选择类型

- 当明确知晓数值不可能为负时，选用无符号类型。
- 使用int执行整数运算。如果数值超过了int的表示范围，选用 long long。
- 在算术表达式中不使用char 或 bool，只在存放字符或布尔值时才使用它们。
- 执行浮点数运算一般选用double。



### 类型转换*(convert)*

- 当把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。

- 当把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。

- 当把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。

- 当把一个整数值赋给浮点类型时，小数部分记为0。结果该整数所占的空间超过了浮点类型的容量，精度可能有损失。

- 当赋给无符号类型一个超出它表示范围的值时，结果是初始值对 **无符号类型表示数值总数** 取模后的余数。

  ```c++
  e.g.
  unsigned int 
  /* 取值范围：0 ~ 4294967295
   * 数值总数：4294967296
   * \\Zero Value Matter// ( ZVM (笑
   */
  ```

  

- 当赋给带符号类型一个超出它表示范围的值时，结果是**未定义的** *(undefind)*。

  ```
    取模运算(mod)和求余(rem)运算被混为一谈，因为在大多数的编程语言里，都用'%'符号表示取模或者求余运算。在这里要提醒大家要十分注意当前环境下'%'运算符的具体意义，因为在有负数存在的情况下，两者的结果是不一样的。
  
    对于整型数a，b来说，取模运算或者求余运算的方法都是：
  
    1.求 整数商： c = a/b;
  
    2.计算模或者余数： r = a - c*b.
  
    求模运算和求余运算在第一步不同: 求余运算在取c的值时，向0 方向舍入；而取模运算在计算c的值时，向负无穷方向舍入。
  
    因此，当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。但是当符号不一致的时候，结果不一样。
  
    具体来说，求模运算结果的符号和b一致，求余运算结果的符号和a一致。
  ```

  *切勿混用带符号类型和无符号类型*

### 字面值常量*(literal)*

#### 整型和浮点字面值

可以将整型字面值写作十进制数、八进制数或是十六进制数的形式。以0开头的整数代表八进制数，以0x或0X 开头的代表十六进制数。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识。

#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是由常量字符构成的**数组** *(array)*。编译器在每个字符串结尾处添加一个**空字符 '\0'**，因此，字符串字面值的实际长度要比它的内容多1。

#### 转义序列*(escape sequence)*

**不可打印** *(nonprintable)*的字符和在C++语言中有特殊含义的字符，程序员都不能直接使用，需要用到转义序列，转义序列均以反斜杠作为开始。

#### 指定字面值的类型

通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。当使用一个长整型字面值时，应使用大写字母L标记。

##### 字符和字符串字面值

|前缀|含义|类型|
|--|--------------|---------|
|u|Unicode 16 字节|char16_t|
|U|Unicode 32 字节|char32_t|
|L|宽字符|wchar_t|
|u8|UTF-8|char|

##### 整型字面值

|后缀|最小匹配类型|
|---------|----------|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|

##### 浮点型字面值

| 后缀   | 类型        |
| ------ | ----------- |
| f or F | float       |
| l or L | long double |

#### 布尔字面值和指针字面值

true 和 false 是布尔类型的字面值。

nullptr 是指针字面值。



## 变量

***变量*** 提供一个具名的、可供程序操作的存储空间。每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，**变量** *(variable)* 和 **对象** *(object)* 一般可以互换使用。

通常情况下，对象是指一块能存储数据并具有某种类型的内存空间，不严格区分是类还是内置类型，也不区分是否命名或是否只读。

### 变量定义

变量定义基本形式是：首先**类型说明符** *(type specifier)*，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。列表中每个变量的类型由类型说明符指定，定义时还可以为一个或多个变量赋初值。

（一个**基本数据类型** *(base type)* 和紧随其后的一个**声明符** *(declarator)* 列表组成。每个声明符命名一个变量并指定该变量为与基本数据类型有关的某种类型。）

```c++
e.g.
int sum = 0, value; 
/* 都是int数据类型
 * 都是int类型 （嗯，上下这俩不是一个东西）
 * sum初值为零
 */
```

当对象在创建时获得了一个特定的值，我们就说这个对象被**初始化** *(initialized)*了。用于初始化变量的值可以是任意复杂的表达式。在C++语言中，赋值和初始化是两个完全不同的操作；初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

#### 列表初始化*(list initialzation)*

无论是初始化对象还是某些时候为对象赋新值，都可以使用一组由花括号括起来的初始值，这种初始化的形式被称为列表初始化。

```c++
e.g.
int units_sold{0};
int units_sold = {0};
```

这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，编译器将会报错。

#### 默认初始化*(default initialized)*

内置类型的变量未被显式初始化，它的值由定义的位置决定。定义与任何函数体之外的变量被初始化为0；定义在函数体内部的内置类型变量将**不被初始化** *(uninitialized)*。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类型将引发错误。类的对象如果没有显式地初始化，则其值由类确定。

### 变量声明和定义的关系

变量声明规定了变量的类型和名字。定义还申请存储空间，也可能会为变量赋一个初始值。变量能且只能被**定义** *(definition)*一次，但是可以被多次**声明** *(declaration)*。变量的定义必须出现在且只能出现在一个文体中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

在变量名前添加关键字**extern**，而且不要显式地初始化变量，即可声明一个变量而不是定义它。

### 标识符*(identifier)*

标识符由字母、数字和下划线组成，其中必须以字母或下划线开头，对长度无限制但大小写敏感。

#### 变量命名规范

- 标识符要能体现实际含义。
- 变量名一般用小写字母。
- 用户自定义的类名一般以大写字母开头。
- 如果标识符由多个单词组成，则单词间应有明显区分，但不能出现两个连续下划线。
- 定义在函数体外的标识符不能以下划线开头。
- 不能以下划线紧连大写字母开头。

### 名字的作用域

**作用域** *(scope)* 是程序的一部分，在其名字有特定的含义。C++语言中大多数作用域都以花括号分隔。同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

具有**全局作用域** *(global scope)* 的名字一旦声明以后，在整个程序的范围内都可使用。

具有**块作用域** *(block scope)* 的名字声明以后，从声明开始到所在作用域末端都可使用。

#### 嵌套的作用域

作用域能彼此包含，被嵌套的作用域称为**内层作用域** *(inner scope)*，包含着别的作用域的作用域被称为**外层作用域** *(outer scope)*。

作用域中一旦声明了某个名字，它所嵌套的所有作用域中都能访问该名字。允许在内层作用域中重新定义外层作用域已有的名字。

## 复合类型*(compound type)*

复合类型是指基于其他类型定义的类型。

### 引用*(reference)*

`严格来说，当我们使用术语“引用(reference)”时，指的是“左值引用(lvalue reference)”。`

引用为对象起了另一个名字。引用类型**引用** *(refers to)* 另一种类型。通过将声明符写成 **&d** 的形式来定义引用类型，其中 **d** 是声明的变量名。

```c++
e.g.
int ival = 1024;
int &refVal = ival; // refVal refers to ival.
```

定义引用时，程序把引用和它的初始值**绑定** *(bind)* 在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起，无法令引用重新绑定到另一个对象。**引用必须初始化。**

#### 引用即别名

引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。

引用本身不是一个对象，不能定义引用的引用。

```c++
e.g.
int ival;
int &(&refVal) = ival; // error
// 有一说一，这么写的人估计是指针学傻了www，“引用的引用”本身不存在，但是好像能跟std标准库和右值引用扯上点关系。
```

#### 引用的定义

除了两种例外情况外，其他所有引用的类型都必须与绑定对象严格匹配。引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

### 指针*(pointer)* 

指针是**指向** *(point to)* 另外一种类型的复合类型。指针本身是一个对象，允许对指针赋值和拷贝，且在指针生命周期内可以先后指向几个不同的对象 ；指针无需在定义时赋初值，在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值。

#### 定义指针的方法

将声明符写成 **\*d** 的形式，其中 **d** 是 变量名。`如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号*。 // In fact, if you understand the "declarator," you won't be confused here.`

#### 获取对象的地址

指针存放某个对象的地址，要获取该地址，需要使用**取地址符** (操作符 **&**)。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了两种例外情况，在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以其他所有指针的类型都要和它所指向的对象严格匹配。

指针的值（即地址）应属于下列4种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。尽管第2种和第3种形式的指针是有效的，但没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。

#### 利用指针访问对象

如果指针指向了一个对象，则允许使用**解引用符** (操作符*****) 来访问对象。 对指针解引用会得出所指的对象，解引用操作仅适用于确定指向了某个对象的有效指针。

#### 空指针*(null pointer)*

空指针不指向任何对象。得到空指针最直接的办法是用字面值 **nullptr** 来初始化指针，nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。

也可以通过将指针初始化为字面值0来生成空指针。`过去的程序还会用到一个名为NULL的预处理变量(preprocessor variable)来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。在新标准下，现在的C++程序最好使用nullptr，同时避免使用NULL。`

#### 其他指针操作

和采用算术值作为条件遵循的规则类似，如果指针的值是0，条件取false，任何非零指针对应的条件值都是true。

对于两个类型相同的合法指针，可以用**相等操作符(==)** 或 **不相等操作符(!=)** 来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的地址值相同(两个指针相等)有三种可能：它们都为空、都指向同一个对象，或者都指向了同一个对象的下一地址。

#### void* 指针

void\*指针是一种特殊的指针类型，可用于存放任意对象的地址。void\*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void\* 指针。不能直接操作void\*指针所指的对象，因为并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

### 理解复合类型的声明

变量的定义包括一个基本数据类型和一组声明符。在同一定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。`关于基本数据类型和类型修饰符的关系，其实后者只不过是声明符的一部分罢了。`

#### 指向指针的指针

指针是对象，所以存在对指针的引用。

```c++
int i = 42;
int *p; // p是一个int型指针
int *&r = p; // r是一个对指针p的引用

/* 要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。
 * 离变量名最近的符号(此例中是&r的符号&)对变量的类型有最直接的影响，因此r是一个引用。
 * 声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。
 * 最后，声明的其本数据类型部分指出r引用的是一个int指针。
 */

r = &i; // r引用了一个指针，因此给r赋值&i就是令p指向i
```

面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。

## const 限定符

用关键字 **const** 对变量的类型加以限定，使它的值不能被改变。因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。

####  默认状态下，const对象仅在文件内有效

如果想在多个文件之间共享const对象，必须在变量的定义之前**添加extern关键字**。