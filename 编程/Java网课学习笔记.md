Java网课学习笔记

这篇笔记是在18年的夏天看网课产生的。我没把网课看完，所以这篇笔记也是不完整的。当时的网课视频我找不到了（去学C++后删了个干净XP）。

# 方法规则

## 构造方法

一种特殊的方法，相当与其它语言的main函数。

```java
public 类名称(参数类型 参数名称, ...){
    方法体
}
```

##  方法定义的格式：

```java
修饰符 返回值类型 方法名(参数列表) {
	……
	return;
}
```



## 方法调用格式：

```java
方法名(实参,...);
```



## 方法的重载（Overload）：

多个方法名称一样，但参数列表不一样





# 常用方法

## if

```java
if(关系表达式){
    语句体;
}
```

### if else

```java
if(关系表达式){
    语句体1;
}else{
    语句体2;
}
```

### if ... else if

```java
if(关系表达式1){
    语句体1;
}else if(关系表达式2){
    语句体2;
}
```

## switch

```java
switch(){
    case 1:
        语句体;
        break;
    ......
    case n:
        语句体;
        break;
    default:
        语句体;
        break;
}
```

## for

```java
for(初始循环体;布尔表达式;步进表达式){
    循环体
}
```

## while

```java
while(条件判断){
    循环体
}
```

### do ... while

```java
do{
    循环体;
}while(条件判断);
```



# 关键字

## break

跳出循环

## continue

跳过这次循环，开始下一次循环。

## private

不能在其它类中直接访问。

### 用于间接访问的成员方法格式

```java
修饰符 void set成员变量名(形参){...} //成员变量名首字母大写
修饰符 类型 get成员变量名(形参){return ...;} //成员变量名首字母大写
修饰符 booleam is成员变量名(形参){return ...;} //成员变量名首字母大写
```

## this

```java
this.成员变量名
```

可以解决局部变量和成员变量重名。

## super

```java
super.父类变量名 //解决父类变量与其它变量重名；访问父类内容
super() //调用父类重载构造
```

## @Override

检测是否为有效的覆盖重写，写在方法定义前即可。

## 权限修饰符

public > protected > /* 空 */ > private

|              | public | protected | (default) | private |
| ------------ | :----: | :-------: | :-------: | :-----: |
| 同一个类     |   ✔    |     ✔     |     ✔     |    ✔    |
| 同一个包     |   ✔    |     ✔     |     ✔     |    ❌    |
| 不同包子类   |   ✔    |     ✔     |     ❌     |    ❌    |
| 不同包非子类 |   ✔    |     ❌     |     ❌     |    ❌    |

## instanceof

```java
对象 instanceof 类名称
//一个二元运算符，判断前者是否能向下转型为后者，返回一个布尔值。
```

## final

表示不可改变。

1. 修饰一个类；
2. 修饰一个方法；
3. 修饰一个局部变量；
4. 修饰一个成员变量；
5. 不能和abstract关键字同时使用。

### 修饰类

```java
public final class 类名称{...} //不能有子类，且其中所有成员方法都无法覆写.
```

### 修饰方法

```java
修饰符 final 返回值类型 方法名称(参数列表){...} //不能被覆写
```

### 修饰局部变量

```java
final 类型 变量名 ... 
```

1. 基本类型：内容数据不可变
2. 引用类型：地址值不可变，内容可变

### 修饰成员变量

1. 格式和局部变量一样
2. 必须手动赋值，直接赋值和构造赋值。
3. 必须所有的重载构造会对final的成员变量赋值。



# 数组

## 动态初始化类型数组

```java
数据类型[].数组名称 = new 数据类型 [数组长度];
```

## 静态初始化

```java
数据类型[] 数组名称 = new 数据类型[] {元素1, 元素2, ...};
```

### 省略格式

```java
数据类型[] 数组名称 = {元素1, 元素2, ...};
```

## 获取数组长度

```java
数组名称.length
```



# 对象

## 导包

```java
import 包名称.类名称
```

## 创建对象

```java
类名称 对象名 = new 类名称();
```

## 使用

### 成员变量

```java
对象名.成员变量名
```

### 成员方法

```java
对象名.成员方法名(形参...)
```



# 包装类

1. Byte
2. Short
3. Integer
4. Long
5. Flaot
6. Double
7. Character
8. Boolean



# 常用类

## Scanner类

```java
Scanner 对象名 = new Scanner(...); //输入
```

## Random类

```java
Random 对象名 = new Random(...); //随机数
```

## ArrayList类

```java
ArrayList<引用类型> 对象名 = new ArrayList<>(); //长度不定的数组
```

## Math类

```java
Math.abs(参数) //获取绝对值
Math.ceil(参数) //向上取整
Math.floor(参数) //向下取整
Math.round(参数) //四舍五入
```



# 字符串

## equals方法

比较两个字符串对象的内容是否相同

```java
参数.equals(参数) //区分大小写
参数.equalsIgnoreCase(参数) //不区分大小写
```

## length()方法

```java
参数.length() //获取字符串长度
```

## concat()方法

```java
参数.concat(参数) //将两个参数拼接成新的字符串
```

## charAt()方法

```java
参数.charAt(参数) //获取指定索引位置字符
```

## indexOf()方法

```java
参数.indexOf(参数字符串) //查找参数字符串第一次出现在参数的位置
```

## substring方法

### substring(int index) 

截取从index处到字符串末尾的字符串。

```java
参数.substring(参数) 
```

### substring(int begin, int end) 

截取从begin到end之间的字符串。

```java
参数.substring(参数, 参数) //左闭右开
```

## toCharArray()方法

```java
参数.toCharArray() //将当前字符串拆分成字符数组
```

## getBytes()方法

```java
参数.getBytes() //获得当前字符串底层的字节数组
```

## replace()方法

```java
参数.replace(原字符串, 新字符串) //获参数中所有指定的字符串替换
```



# 父子类

## 父类定义

```java
public class 父类名称(){...}
```

## 子类定义

```java
public class 子类名称 extends 父类名称(){...}
```

## 对象的向下转型

```java 
子类名称 对象名 = (子类名称)父类对象名; //父类对象必须在创建时是子类，才能向下转型还原成子类对象。
```



# 抽象类

```java
修饰符 abstract class 类名{...}
```

1. 不能直接new对象；
2. 必须用一个子类继承抽象父类；
3. 子类必须覆写抽象父类中的所有抽象方法；
4. 覆盖重写（实现）：子类去掉抽象方法的abstract关键字，补上方法体花括号。
5. 创建子类对象使用。

## 抽象方法

```java
修饰符 abstract 返回值类型 方法名(); //抽象方法所在类必须为抽象类
```



# 接口

```java
public interface 接口名称{...}
```

1. 不能直接使用；
2. 必须有一个“实现类”来实现接口；
3. 实现类必须覆写接口中所有的抽象方法；
4. 创建实现类的对象使用。

## 接口中定义成员变量

```java
public static final 类型 名称 = 数据值;
```

1. 必须使用public static final 进行修饰；
2. 可以省略public static final，效果不变；
3. 必须在定义时赋值，赋值后不可改变；
4. 名称必须全大写，单词之间用下划线分隔；
5. 这和常量有锤子区别。

## 接口中定义默认方法

```java
public default 类型 方法名称(参数列表){...} //public可省略；默认方法也可以在实现类中覆写。
```

## 接口中定义静态方法

```java
public static 类型 方法名称(参数列表){...} 
// 不能通过实现类的对象调用接口中的静态方法，直接通过接口名称调用
接口名称.静态方法名(参数...)；
```

## 接口中定义私有方法

### 普通私有方法

```java
private 类型 方法名称(参数列表){...} //解决多个默认方法之间的重复代码问题
```

### 静态私有方法

```java
private static 类型 方法名称(参数列表){...}
```

## 接口实现类

```java
public class 实现类名称 implements 接口名1, 接口名2, ...{...} //一个实现类可实现多个接口
```

## 接口中定义抽象类

```java
public abstract 类型 名称(参数...); //public abstract可省略，但不能为其它。
```



# 多态性

## 代码中体现多态性

```java
父类名 对象名 = new 子类名();
接口名 对象名 = new 实现类名(); // 二者效果相同
```

## 多态中使用成员变量

1. 直接通过对象名称访问成员变量：优先等号左边，没有则向上找；
2. 间接通过成员方法访问成员变量：优先方法属于的类，没有则向上找；
3. 口诀：编译看左，运行看右。



# 内部类

## 成员内部类

```java
修饰符 class 外部类名称{
    修饰符 class 内部类名称{...}
    ...
} //内部类可以随意访问外部类，外部类访问内部类需要对象。
```

间接使用：在外部类的方法中，使用内部类；

直接使用：

```java
外部类名.内部类名 对象名 = new 外部类名().new
```

同名变量访问：

```java
外部类名.this.外部类成员变量名
```

## 局部内部类

```java
修饰符 class 外部类名称{
    修饰符 返回值类型 外部类访问方法名称(参数列表){
        class 局部内部类名称{...}
    	...
    }    
} //只能在所属方法里使用。在所属方法中创建一个内部类对象使用。局部内部类访问的局部变量，必须是final的.
```

## 匿名内部类

```java
接口名称 对象名 = 接口名称(){/* 覆写所有抽象方法 */};

new 接口名称(){/* 覆写所有抽象方法 */}.方法名称(); //省略对象名称的定义格式
```



【End】
