《Python编程快速上手——让繁琐工作自动化》学习笔记

# 基础
## 数学操作符

优先级从高到低递减。

| 操作符 | 操作 | 例子 | 求值为 |
|:----:|:----:|:----:|:----:|
|   **   |   指数   |   2 ** 3   |   8   |
|   %   |   取模/取余数   |   22 % 8   |   6   |
|   //   |   整除/商数取整   |   22 // 8   |   2   |
|   /   |   除法   |   22 / 8   |   2.75   |
|   *   |   乘法   |   3 * 5   |   15   |
|   -   |   减法   |   5 - 2   |   3   |
|   +   |   加法   |   2 + 2   |   4   |

## 整型、浮点型和字符串数据类型
表达式是值和操作符的组合

“数据类型”是一类值，每个值都只属于一种数据类型。

1. 整型（或int）数据类型表明值是整数；
2. 带有小数点的数，称为“浮点型”（或float）；
3. 文本值，称为“字符串”，或strs（发音为“stirs”），总是用单引号（'）包围住字符串。

虽然数字的字符串值被认为与整型值和浮点型值完全不同，但整型值可以与浮点值相等。

> 错误信息SyntaxError: EOL while scanning string literal，可能是忘记了字符串末尾的单引号

## 字符串连接和复制

+在用于两个字符串时，成为“字符串连接”操作符，作用是将字符串连接起来求得一个新字符串。

*操作符在用于一个字符串值和一个整型值时，成为“字符串复制”操作符。求值为一个字符串，它将原来的字符串重复若干次，次数就是整型的值。

## 变量
### 赋值语句
赋值语句包含一个变量名（左值）、一个等号（称为赋值操作符），以及要存储的值（右值）。

### 变量名

变量有以下命名规则：

1. 只能是一个词。
2. 只能包含字母、数字和下划线。
3. 不能以数字开头。

变量名是区分大小写的。

## 注释
“#”标志之后的所有文本都是注释，Python会忽略注释，用它们来为程序写注解。

## print()函数
print()函数将括号内的字符串显示在屏幕上。

## input()函数
input()函数等待用户在键盘上输入一些文本，并按下回车键。

这个函数求值为一个字符串，即用户输入的文本。

## len()函数
向len()函数传递一个字符串（或包含字符串的变量），然后该函数求值为一个整型值，即字符串中字符的个数。

**【太长不看版：求字符串长度】**

## str()、int()和float()函数
str()、int()和float()函数将分别求值为传入值的字符串、整数和浮点数形式。

# 控制流
## 布尔值
Boolean（布尔）的首字母大写，因为这个数据类型是根据数学家George Boole命名的。

“布尔”数据类型只有两种值：True和False。

## 比较操作符
“比较操作符”比较两个值，求值为一个布尔值。

| 操作符 | 含义 |
|:----:|:----:|
|   ==   |   等于   |
|   !=   |   不等于   |
|   <   |   小于   |
|   >   |   大于   |
|   <=   |   小于等于   |
|   >=   |   大于等于   |

==和!=操作符实际上可以用于所有数据类型的值。<、>、<=和>=操作符仅用于整型和浮点型值。

## 布尔操作符
3个布尔操作符（and、or和not）用于比较布尔值，它们求值为一个布尔值。

计算机将先求值左边的表达式，然后再求值右边的表达式。知道两个布尔值后，它又将整个表达式再求值为一个布尔值。

在所有算术和比较操作符求值后，Python先求值not操作符，然后是and操作符，然后是or操作符。

### 二元布尔操作符
and和or操作符总是接受两个布尔值（或表达式）。

“真值表”显示了布尔操作符的所有可能结果。

#### and操作符真值表

| 表达式 | 求值为 |
|:----:|:----:|
|   True and True   |   True   |
|   True and False   |   False   |
|   False and True   |   False   |
|   False and False   |   False   |

#### or操作符真值表

| 表达式 | 求值为 |
|:----:|:----:|
|   True or True   |   True   |
|   True or False   |   True   |
|   False or True   |   True   |
|   False or False   |   True   |

### not操作符
not操作符只作用于一个布尔值（或表达式）。not操作符求值为相反的布尔值。

| 表达式 | 求值为 |
|:----:|:----:|
|   not True   |   False   |
|   not False   |   True   |

## 控制流元素
“条件”只是在控制流语句的上下文中更具体的名称。条件总是求值为一个布尔值，True或False。

一些代码行可以作为一组，放在“代码块”中。代码块有3条规则：
1. 缩进增加时，代码块开始。
2. 代码块可以包含其他代码块。
3. 缩进减少为零，或减少为外面包围代码块的缩进，代码块就结束了。

## 控制流语句
### if语句
if语句的子句（也就是紧跟if语句的语句块），将在语句的条件为True时执行。如果条件为False，子句将跳过。

在Python中，if语句包含以下部分：
- if关键字；
- 条件（即求值为True或False的表达式）；
- 冒号；
- 在下一行开始，缩进的代码块（称为if子句）。

### else语句
if子句后面有时候也可以跟着else语句。只有if语句的条件为False时，else子句才会执行。

else语句不包含条件，在代码中，else语句中包含下面部分：
- else关键字；
- 冒号；
- 在下一行开始，缩进的代码块（称为else子句）。

### elif语句
elif语句提供了另一个条件，仅在前面的if或elif语句条件为False时才检查该条件。在代码中，elif语句总是包含以下部分：
- elif关键字；
- 条件（即求值为True或False的表达式）；
- 冒号；
- 在下一行开始，缩进的代码块（称为elif子句）。

如果有一系列的elif语句，仅有一条或零条子句会被执行。一旦一个语句的条件为True，剩下的elif子句会自动跳过。

在最后的elif语句后面加上else语句。在这种情况下，如果每个if和elif语句中的条件都为False，就执行else子句。

### while循环语句
在while循环中，条件总是在每次“迭代”开始时检查（也就是每次循环执行时）。如果条件为True，子句就会执行，然后，再次检查条件。当条件第一次为False时，while子句就跳过。

在代码中，while语句总是包含下面几部分：
- 关键字；
- 条件（求值为True或False的表达式）；
- 冒号；
- 从新行开始，缩进的代码块（称为while子句）。

### break语句
如果执行遇到break语句，就会马上退出循环子句。在代码中，break语句仅包含break关键字。

### continue语句
continue语句用于循环内部。

如果程序执行遇到continue语句，就会马上跳回到循环开始处，重新对循环条件求值（这也是执行到达循环末尾时发生的事情）。

continue语句将让for循环变量继续下一个值，就像程序执行已经到达循环的末尾并返回开始一样。

实际上，只能在while和for循环内部使用continue和break语句。如果试图在别处使用这些语句，Python将报错。

### for循环和range()函数
for语句总是包含以下部分：
- for关键字；
- 一个变量名；
- in关键字；
- 调用range()方法，最多传入3个参数；
- 冒号；
- 从下一行开始，缩退的代码块（称为for子句）。

```python
# Example:
print('My name is')
for i in range(5):
    print('Jimmy Five Times (' + str(i) + ')')

# results:
My name is
Jimmy Five Times (0)
Jimmy Five Times (1)
Jimmy Five Times (2)
Jimmy Five Times (3)
Jimmy Five Times (4)
```
#### range()的开始、停止和步长参数
range()的三个参数：
1. for循环变量开始的值
2. 上限，但不包含它，也就是循环停止的数字。
3. “步长”。步长是每次迭代后循环变量增加的值。

可以用负数作为步长参数，让循环计数逐渐减少，而不是增加。

【实际上range()函数不单纯用于for()函数中，它在别处有更加复杂的含义，这里单纯说明的只是其在for()函数中的含义。】

## 导入模块
在开始使用一个模块中的函数之前，必须用import语句导入该模块。在代码中，import语句包含以下部分：
- import关键字；
- 模块的名称；
- 可选的更多模块名称，之间用逗号隔开。

### from import语句 
import语句的另一种形式包括from关键字，之后是模块名称，import关键字和一个星号。

```python
# example:
from random import *
```

使用这种形式的import语句，调用模块中的函数时不需要模块名前缀。

## 用sys.exit()提前结束程序
通过调用sys.exit()函数，可以让程序终止或退出。

该函数在sys模块中，必须先导入sys，才能使用。

# 函数
## def语句和参数
def语句之后的代码块是函数。这段代码在函数调用时执行，而不是在函数第一次定义时执行。【说人话：def语句用来定义函数】

## 返回值和return语句
函数调用求值的结果，称为函数的“返回值”。用def语句创建函数时，可以用return语句指定应该返回什么值。

return语句包含以下部分：
- return关键字；
- 函数应该返回的值或表达式。

## None值
在Python中有一个值称为None，它表示没有值。None是NoneType数据类型的唯一值（其他编程语言可能称这个值为null、nil或undefined）。

在幕后，对于所有没有return语句的函数定义，Python都会在末尾加上return None。

## 关键字参数和print()
“关键字参数”是由函数调用时加在它们前面的关键字来识别的。关键字参数通常用于可选变元。

### print()
print()函数有可选的变元end和sep，分别指定在参数末尾打印什么，以及在参数之间打印什么来隔开它们。

```python
# example:
print('Hello', end='')
print('World') 
# 输出：
HelloWorld
```

如果向print()传入多个字符串值，该函数就会自动用一个空格分隔它们。通过传入sep关键字参数，可以替换掉默认的分隔字符串。

```python
# example
>>> print('cats', 'dogs', 'mice') 
cats dogs mice

#୨୧┈┈┈┈┈┈┈┈┈┈┈┈┈┈୨୧

>>>  print('cats', 'dogs', 'mice', sep=',') 
cats,dogs,mice
```

## 局部和全局作用域
在被调用函数内赋值的变元和变量，处于该函数的“局部作用域”。处于局部作用域的变量，被称为“局部变量”。

一个函数被调用时，就创建了一个局部作用域。在这个函数内赋值的所有变量，存在于该局部作用域内。该函数返回时，这个局部作用域就被销毁了，这些变量就丢失了。

在所有函数之外赋值的变量，属于“全局作用域”。处于全局作用域的变量，被称为“全局变量”。

作用域的重要性：
- 全局作用域中的代码不能使用任何局部变量；
- 局部作用域可以访问全局变量；
- 一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量。
- 在不同的作用域中，可以用相同的名字命名不同的变量。

## global语句
global语句用于在一个函数内修改全局变量。

区分一个变量是处于局部作用域还是全局作用域：
1. 如果变量在全局作用域中使用（即在所有函数之外），它就总是全局变量。
2. 如果在一个函数中，有针对该变量的global语句，它就是全局变量。
3. 否则，如果该变量用于函数中的赋值语句，它就是局部变量。
4. 但是，如果该变量没有用在赋值语句中，它就是全局变量。

## 异常处理
错误可以由try和except语句来处理。那些可能出错的语句被放在try子句中。如果错误发生，程序执行就转到接下来的except子句开始处。

一旦执行跳到except子句的代码，就不会回到try子句。

# 列表
## 列表数据类型
“列表”是一个值，它包含多个字构成的序列。

术语“列表值”指的是列表本身（它作为一个值，可以保存在变量中，或传递给函数，像所有其他值一样），而不是指列表值之内的那些值。

列表用左方括号开始，右方括号结束，即[]。列表中的值也称为“表项”。表项用逗号分隔（就是说，它们是“逗号分隔的”）。

```python
# example
 >>>  spam = ['cat', 'bat', 'rat', 'elephant'] 
 >>>  spam 
 ['cat', 'bat', 'rat', 'elephant']
```
### 用下标取得列表中的单个值
列表后面方括号内的整数被称为“下标”。下标从0开始，只能是整数，不能是浮点值。

列表也可以包含其他列表值。这些列表的列表中的值，可以通过多重下标来访问

```python
# example
>>> spam = [['cat', 'bat'], [10, 20, 30, 40, 50]] 
>>> spam[0] 
['cat', 'bat']
>>> spam[0][1] 
'bat'
>>> spam[1][4] 
50
```

如果使用的下标超出了列表中值的个数，Python将给出IndexError出错信息。

### 负数下标
整数值−1指的是列表中的最后一个下标，−2指的是列表中倒数第二个下标，以此类推。

### 利用切片取得子列表
“切片”可以从列表中取得多个值，结果是一个新列表。切片输入在一对方括号中，像下标一样，但它有两个被冒号分隔的整数。

在一个切片中，第一个整数是切片开始处的下标。第二个整数是切片结束处的下标（左闭右开）。

作为快捷方法，可以省略切片中冒号两边的一个下标或两个下标：
1. 省略第一个下标相当于使用0，或列表的开始。
2. 省略第二个下标相当于使用列表的长度，意味着分片直至列表的末尾。

### 用len()取得列表的长度
len()函数将返回传递给它的列表中值的个数，就像它能计算字符串中字符的个数一样。

### 列表连接和列表复制
+操作符可以连接两个列表，得到一个新列表，就像它将两个字符串合并成一个新字符串一样。

*操作符可以用于一个列表和一个整数，实现列表的复制。

```python
# example
>>>  [1, 2, 3] + ['A', 'B', 'C']
[1, 2,  3,  'A',  'B',  'C']
>>>  ['X', 'Y', 'Z'] * 3
['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z']
>>>  spam = [1, 2, 3]
>>>  spam = spam + ['A', 'B', 'C']
>>> spam
[1, 2, 3, 'A', 'B', 'C']
```

### 用del语句从列表中删除值
del语句将删除列表中下标处的值，表中被删除值后面的所有值，都将向前移动一个下标。

del语句也可用于一个简单变量，删除它，作用就像是“取消赋值”语句。如果在删除之后试图使用该变量，就会遇到NameError错误，因为该变量已不再存在。

## 使用列表
### 列表用于循环
一个常见的Python技巧，是在for循环中使用range(len(someList))，迭代列表的每一个下标。

### in和not in操作符
in和not in用在表达式中，连接两个值：一个要在列表中查找的值，以及待查找的列表。这些表达式将求值为布尔值。

```python
# example
>>> 'howdy' in ['hello', 'hi', 'howdy', 'heyas'] 
True
>>> spam = ['hello', 'hi', 'howdy', 'heyas'] 
>>> 'cat' in spam 
False
>>> 'howdy' not in spam 
False
>>> 'cat' not in spam 
True
```

### 多重赋值技巧
多重赋值技巧是一种快捷方式，让你在一行代码中，用列表中的值为多个变量赋值。

```python
# example
>>>  cat = ['fat', 'black', 'loud'] 
>>>  size, color, disposition = cat
# 等价于
>>>  cat = ['fat', 'black', 'loud'] 
>>>  size = cat[0] 
>>>  color = cat[1] 
>>>  disposition = cat[2] 
```

变量的数目和列表的长度必须严格相等，否则Python将给出ValueError。

## 增强的赋值操作
增强的赋值操作符表

| 增强的赋值语句 | 等价的赋值语句 |
|:----:|:----:|
|   spam += 1   |   spam = spam + 1   |
|   spam -= 1   |   spam = spam - 1   |
|   spam *= 1   |   spam = spam * 1   |
|   spam /= 1   |   spam = spam / 1   |
|   spam %= 1   |   spam = spam % 1   |

+=操作符也可以完成字符串和列表的连接，*=操作符可以完成字符串和列表的复制。

## 方法
方法和函数是一回事，只是它是调用在一个值上。方法部分跟在这个值后面，以一个句点分隔。

每种数据类型都有它自己的一组方法。

### 用index()方法在列表中查找值
列表值有一个index()方法，可以传入一个值，如果该值存在于列表中，就返回它的下标。如果该值不在列表中，Python就报ValueError。

如果列表中存在重复的值，就返回它第一次出现的下标。

### 用append()和insert()方法在列表中添加值
要在列表中添加新值，就使用append()和 insert()方法。

append()方法，将参数添加到列表末尾。

insert()方法可以在列表任意下标处插入一个值。insert()方法的第一个参数是新值的下标，第二个参数是要插入的新值。

append()和insert()都不会将spam的新值作为其返回值（实际上，append()和insert()的返回值是None）。但是，列表被“当场”修改了。

方法属于单个数据类型。append()和insert()方法是列表方法，只能在列表上调用，不能在其他值上调用。

### 用remove()方法从列表中删除值
给 remove()方法传入一个值，它将从被调用的列表中删除。

试图删除列表中不存在的值，将导致ValueError错误。

如果该值在列表中出现多次，只有第一次出现的值会被删除。

### 用sort()方法将列表中的值排序
数值的列表或字符串的列表，能用sort()方法排序。也可以指定reverse关键字参数为True，让sort()按逆序排序。

关于sort()方法，应该注意3件事：
1. sort()方法当场对列表排序。不要试图记录返回值。
2. 不能对既有数字又有字符串值的列表排序，因为Python不知道如何比较它们。
3. sort()方法对字符串排序时，使用“ASCII字符顺序”，而不是实际的字典顺序。这意味着大写字母排在小写字母之前。

如果需要按照普通的字典顺序来排序，就在sort()方法调用时，将关键字参数key设置为str.lower。这将导致sort()方法将列表中所有的表项当成小写，但实际上并不会改变它们在列表中的值。

```python
# example
>>>  spam = ['a', 'z', 'A', 'Z'] 
>>>  spam.sort(key=str.lower) 
>>>  spam 
['a', 'A', 'z', 'Z']
```

## 类似列表的类型：字符串和元组
对列表的许多操作，也可以作用于字符串：按下标取值、切片、用于for循环、用于len()，以及用于in和not in操作符。

### 可变和不可变数据类型
列表和字符串在一个重要的方面是不同的。列表是“可变的”数据类型，它的值可以添加、删除或改变。但是，字符串是“不可变的”，它不能被更改。尝试对字符串中的一个字符重新赋值，将导致TypeError错误。

“改变”一个字符串的正确方式，是使用切片和连接。构造一个“新的”字符串，从老的字符串那里复制一些部分。

### 元组数据类型
元组”数据类型几乎与列表数据类型一样，区别在于：
1. 元组输入时用圆括号()，而不是用方括号[]。
2. 元组像字符串一样，是不可变的。元组不能让它们的值被修改、添加或删除。

如果元组中只有一个值，在括号内该值的后面跟上一个逗号。否则，Python将认为，你只是在一个普通括号内输入了一个值。逗号告诉Python，这是一个元组。

使用元组好处：
1. 用元组告诉所有读代码的人，这是一个永远不会改变的值的序列，别打算改变这个序列的值。
2. Python可以实现一些优化，让使用元组的代码比使用列表的代码更快。

### 用list()和tuple()函数来转换类型
函数list()和tuple()将返回传递给它们的值的列表和元组版本

## 引用
当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。【我超，~~冰！~~ 指针！】

变量包含对列表值的引用，而不是列表值本身。但对于字符串和整数值，变量就包含了字符串或整数值。

### 传递引用
当函数被调用时，参数的值被复制给变元。对于列表（以及字典），这意味着变元得到的是引用的拷贝。

⚠请记住这种行为：如果忘了Python处理列表和字典变量时采用这种方式，可能会导致令人困惑的缺陷。

### copy模块的copy()和deepcopy()函数
Python提供了名为copy的模块，其中包含copy()和deepcopy()函数。

第一个函数copy.copy()，可以用来复制列表或字典这样的可变值，而不只是复制引用。

如果要复制的列表中包含了列表，那就使用copy.deepcopy()函数来代替。deepcopy()函数将同时复制它们内部的列表。

# 字典和结构化数据
## 字典数据类型
“字典”是许多值的集合。但不像列表的下标，字典的索引可以使用许多不同数据类型，不只是整数。字典的索引被称为“键”，键及其关联的值称为“键-值”对。

在代码中，字典输入时带花括号{}。

```python
# example
>>>  myCat['size'] 
'fat'
>>>  'My cat has ' + myCat['color'] + ' fur.' 
'My cat has gray fur.'
```

### 字典与列表
不像列表，字典中的表项是不排序的。在字典中，键-值对输入的顺序并不重要。因为字典是不排序的，所以不能像列表那样切片。

尝试访问字典中不存在的键，将导致KeyError出错信息。

### keys()、values()和items()方法
keys()、values()和items()将返回类似列表的值，分别对应于字典的键、值和键-值对。

这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型（分别是dict_keys、dict_values和dict_items）可以用于for循环。items()方法返回的dict_items值中，包含的是键和值的元组

### 检查字典中是否存在键或值
in和not in操作符也可以检查某个键或值是否存在于字典中。

### get()方法
字典的get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。

### setdefault()方法
setdefault()为字典中某个键设置一个默认值，当该键没有任何值时使用它。

传递给该方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。如果该键确实存在，方法就会返回键的值。

setdefault()方法是一个很好的快捷方式，可以确保一个键存在。

## 漂亮打印【?】
在程序中导入pprint模块，就可以使用pprint()和pformat()函数，它们将“漂亮打印”一个字典的字。


# 字符串操作
## 处理字符串
### 字符串字面量
在Python中输入字符串值相当简单的：它们以单引号开始和结束。

### 双引号
字符串可以用双引号开始和结束，就像用单引号一样。使用双引号的一个好处，就是字符串中可以使用单引号字符。

### 转义字符
“转义字符”让你输入一些字符，它们用其他方式是不可能放在字符串里的。

转义字符表
| 转义字符 | 打印为 |
|:----:|:----:|
|   \'   |   单引号   |
|   \"   |   双引号   |
|   \t   |   制表符   |
|   \n   |   换行符   |
|   \\   |   倒斜杠   |

### 原始字符串
可以在字符串开始的引号之前加上r，使它成为原始字符串。“原始字符串”完全忽略所有的转义字符，打印出字符串中所有的倒斜杠。

### 用三重引号的多行字符串
在Python中，多行字符串的起止是3个单引号或3个双引号。“三重引号”之间的所有引号、制表符或换行，都被认为是字符串的一部分。Python的代码块缩进规则不适用于多行字符串。

### 多行注释
虽然井号字符（#）表示这一行是注释，但多行字符串常常用作多行注释。

【什么鬼特性，挺会玩啊😅】

### 字符串下标和切片
字符串像列表一样，可以使用下标和切片。字符串中的每个字符都是一个表项，有对应的下标；字符计数包含了空格和感叹号。

请注意，字符串切片并没有修改原来的字符串。

### 字符串的in和not in操作符
像列表一样，in和not in操作符也可以用于字符串。用in或not in连接两个字符串得到的表达式，将求值为布尔值True或False。

## 有用的字符串方法
### 字符串方法upper()、lower()、isupper()和islower()
upper()和lower()字符串方法返回一个新字符串，其中原字符串的所有字母都被相应地转换为大写或小写。字符串中非字母字符保持不变。

如果需要进行大小写无关的比较，upper()和lower()方法就很有用。

如果字符串至少有一个字母，并且所有字母都是大写或小写，isupper()和islower()方法就会相应地返回布尔值True。否则，该方法返回False。【简单来说，检查大小写的。】

```python
# example
>>>  spam = 'Hello world!' 
>>>  spam.islower() 
False
>>>  spam.isupper() 
False
>>>  'HELLO'.isupper() 
True
>>>  'abc12345'.islower() 
True
>>>  '12345'.islower() 
False
>>>  '12345'.isupper() 
False
```

### isX字符串方法
除了islower()和isupper()，还有几个字符串方法，它们的名字以is开始。这些方法返回一个布尔值，描述了字符串的特点。

- isalpha()返回True，如果字符串只包含字母，并且非空；
- isalnum()返回True，如果字符串只包含字母和数字，并且非空；
- isdecimal()返回True，如果字符串只包含数字字符，并且非空；
- isspace()返回True，如果字符串只包含空格、制表符和换行，并且非空；
- .istitle()返回True，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。

### 字符串方法startswith()和endswith()
startswith()和endswith()方法返回True，如果它们所调用的字符串以该方法传入的字符串开始或结束。否则，方法返回False。

### 字符串方法join()和split()
join()方法在一个字符串上调用，参数是一个字符串列表，返回一个字符串。返回的字符串由传入的列表中每个字符串连接而成。调用join()方法的字符串，会被插入到列表参数中每个字符串的中间。

split()方法针对一个字符串调用，返回一个字符串列表。向split()方法传入一个分割字符串，指定它按照不同的字符串分割。

```python
#example
>>>  ', '.join(['cats', 'rats', 'bats']) 
'cats, rats, bats'
>>>  ' '.join(['My', 'name', 'is', 'Simon']) 
'My name is Simon'
>>>  'ABC'.join(['My', 'name', 'is', 'Simon']) 
'MyABCnameABCisABCSimon'

>>> 'My name is Simon'.split() 
['My', 'name', 'is', 'Simon']
>>> 'MyABCnameABCisABCSimon'.split('ABC') 
['My', 'name', 'is', 'Simon']
>>> 'My name is Simon'.split('m') 
['My na', 'e is Si', 'on']
```

### 用rjust()、ljust()和center()方法对齐文本
rjust()和ljust()字符串方法返回调用它们的字符串的填充版本，通过插入空格来对齐文本。这两个方法的第一个参数是一个整数长度，用于对齐字符串。第二个可选参数将指定一个填充字符，取代空格字符。

center()字符串方法与ljust()与rjust()类似，但它让文本居中，而不是左对齐或右对齐。

### 用strip()、rstrip()和lstrip()删除空白字符
trip()字符串方法将返回一个新的字符串，它的开头或末尾都没有空白字符。lstrip()和rstrip()方法将相应删除左边或右边的空白字符。

有一个可选的字符串参数，指定两边的哪些字符应该删除。

### 用pyperclip模块拷贝粘贴字符串
pyperclip模块有copy()和paste()函数，可以向计算机的剪贴板发送文本，或从它接收文本。

pyperclip模块不是Python自带的。

# 模式匹配与正则表达式
## 用正则表达式查找文本模式
正则表达式，简称为regex，是文本模式的描述方法。
### 创建正则表达式对象
Python中所有正则表达式的函数都在re模块中。

向re.compile()传入一个字符串值，表示正则表达式，它将返回一个Regex模式对象（或者就简称为Regex对象）。

### 匹配Regex对象
Regex对象的search()方法查找传入的字符串，寻找该正则表达式的所有匹配。

如果字符串中没有找到该正则表达式模式，search()方法将返回None。如果找到了该模式，search()方法将返回一个Match对象。

Match对象有一个group()方法，它返回被查找字符串中实际匹配的文本。

### 正则表达式匹配复习 
虽然在Python中使用正则表达式有几个步骤，但每一步都相当简单。
1. 用import re导入正则表达式模块。
2. 用re.compile()函数创建一个Regex对象（记得使用原始字符串）。
3. 向Regex对象的search()方法传入想查找的字符串。它返回一个Match对象。
4. 调用Match对象的group()方法，返回实际匹配文本的字符串。

## 用正则表达式匹配更多模式
### 利用括号分组
添加括号将在正则表达式中创建“分组”，然后可以使用group()匹配对象方法，从一个分组中获取匹配的文本。

正则表达式字符串中的组从整数1起算，向group()匹配对象方法传入不同整数，就可以取得匹配文本的不同部分。向group()方法传入0或不传入参数，将返回整个匹配的文本。

想要一次就获取所有的分组，就使用groups()方法。

### 用管道匹配多个分组
字符|称为“管道”。希望匹配许多表达式中的一个时，就可以使用它。

如果多个表达式都出现在被查找的字符串中，第一次出现的匹配文本，将作为Match对象返回。

### 用问号实现可选匹配
字符?表明它前面的分组在这个模式中是可选的。可以认为?是在说，“匹配这个问号之前的分组零次或一次”。

### 用星号匹配零次或多次
*（称为星号）意味着“匹配零次或多次”，即星号之前的分组，可以在文本中出现任意次。它可以完全不存在，或一次又一次地重复。

### 用加号匹配一次或多次
+（加号）则意味着“匹配一次或多次”。加号前面的分组必须“至少出现一次”。这不是可选的。

### 用花括号匹配特定次数
在正则表达式中该分组的后面，跟上花括号包围的数字，意味着一个分组重复特定次数。

除了一个数字，还可以指定一个范围，即在花括号中写下一个最小值、一个逗号和一个最大值。

## 贪心和非贪心匹配
Python的正则表达式默认是“贪心”的，这表示在有二义的情况下，它们会尽可能匹配最长的字符串。花括号的“非贪心”版本匹配尽可能最短的字符串，即在结束的花括号后跟着一个问号。

## findall()方法
Regex对象也有一个findall()方法。findall()方法将返回一组字符串，包含被查找字符串中的所有匹配。

1．如果调用在一个没有分组的正则表达式上，方法findall()将返回一个匹配字符串的列表。

2．如果调用在一个有分组的正则表达式上，方法findall()将返回一个字符串的元组的列表（每个分组对应一个字符串）

## 字符分类
常用字符分类的缩写代码表

| 缩写字符分类 | 表示 |
|:----:|:----:|
|   \d   |   0到9的任何数字   |
|   \D   |   除0到9的数字以外的任何字符   |
|   \w   |   任何字母、数字或下划线字符（可以认为是匹配“单词”字符）   |
|   \W   |   除字母、数字和下划线以外的任何字符   |
|   \s   |   空格、制表符或换行符（可以认为是匹配“空白”字符）   |
|   \S   |   除空格、制表符和换行符以外的任何字符   |

## 建立自己的字符分类
可以用方括号定义自己的字符分类。也可以使用短横表示字母或数字的范围。方括号内，普通的正则表达式符号不会被解释。【属于是关键字查找】

```python
# example
>>> vowelRegex = re.compile(r'[aeiouAEIOU]') 
>>> vowelRegex.findall('RoboCop eats baby food. BABY FOOD.') 
['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O']
```

通过在字符分类的左方括号后加上一个插入字符（^），就可以得到“非字符类”。非字符类将匹配不在这个字符类中的所有字符。

## 插入字符和美元字符
可以在正则表达式的开始处使用插入符号（^），表明匹配必须发生在被查找文本开始处。

类似地，可以在正则表达式的末尾加上美元符号（$），表示该字符串必须以这个正则表达式的模式结束。

## 通配字符
在正则表达式中，.（句点）字符称为“通配符”。它匹配除了换行之外的所有字符。

### 用点-星匹配所有字符
点-星使用“贪心”模式：它总是匹配尽可能多的文本。要用“非贪心”模式匹配所有文本，就使用点-星和问号。

### 用句点字符匹配换行
点-星将匹配除换行外的所有字符。通过传入re.DOTALL作为re.compile()的第二个参数，可以让句点字符匹配所有字符，包括换行字符。

## 正则表达式符号复习
- ?匹配零次或一次前面的分组。
- *匹配零次或多次前面的分组。
- +匹配一次或多次前面的分组。
- {n}匹配n次前面的分组。
- {n,}匹配n次或更多前面的分组。
- {,m}匹配零次到m次前面的分组。
- {n,m}匹配至少n次、至多m次前面的分组。
- {n,m}?或*?或+?对前面的分组进行非贪心匹配。
- ^spam意味着字符串必须以spam开始。
- spam$意味着字符串必须以spam结束。
- .匹配所有字符，换行符除外。
- \d、\w和\s分别匹配数字、单词和空格。
- \D、\W和\S分别匹配出数字、单词和空格外的所有字符。
- [abc]匹配方括号内的任意字符（诸如a、b或c）。
- [^abc]匹配不在方括号内的任意字符。

## 不区分大小写的匹配
通常，正则表达式用你指定的大小写匹配文本。

要让正则表达式不区分大小写，可以向re.compile()传入re.IGNORECASE或re.I，作为第二个参数。

## 用sub()方法替换字符串
Regex对象的sub()方法需要传入两个参数。
- 第一个参数是一个字符串，用于取代发现的匹配。
- 第二个参数是一个字符串，即正则表达式。
- sub()方法返回替换完成后的字符串。

## 管理复杂的正则表达式
可以向re.compile()传入变量re.VERBOSE，作为第二个参数。这告诉re.compile()，忽略正则表达式字符串中的空白符和注释。

然后就可以利用三重引号的特性了。

## 组合使用re.IGNOREC ASE、re.DOTALL和re.VERBOSE
re.compile()函数只接受一个值作为它的第二参数。可以使用管道字符（|）将变量组合起来，从而绕过这个限制。管道字符在这里称为“按位或”操作符。

# 读写文件
## 文件与文件路径
文件有两个关键属性：“文件名”（通常写成一个单词）和“路径”。文件名中，最后一个句点之后的部分称为文件的“扩展名”，它指出了文件的类型。

文件夹名称和文件名在Windows和OS X上是不区分大小写的，但在Linux上是区分大小写的。在Windows上，路径书写使用倒斜杠作为文件夹之间的分隔符。但在OS X和Linux上，使用正斜杠作为它们的路径分隔符。

将单个文件和路径上的文件夹名称的字符串传递给os.path.join()，它就会返回一个文件路径的字符串，包含正确的路径分隔符。

```python
# example
# 该例子为windows
>>>  import os 
>>>  os.path.join('usr', 'bin', 'spam') 
'usr\\bin\\spam'
```

### 当前工作目录
每个运行在计算机上的程序，都有一个“当前工作目录”，所有没有从根文件夹开始的文件名或路径，都假定在当前工作目录下。

利用os.getcwd()函数，可以取得当前工作路径的字符串，并可以利用os.chdir()改变它。

> 虽然文件夹是目录的更新的名称，但请注意，当前工作目录（或当前目录）是标准术语，没有当前工作文件夹这种说法。

### 绝对路径与相对路径
有两种方法指定一个文件路径：
- “绝对路径”，总是从根文件夹开始。
- “相对路径”，它相对于程序的当前工作目录。

单个的句点（.）用作文件夹目名称时，是“这个目录”的缩写。两个句点（..）意思是父文件夹。

### 用os.makedirs()创建新文件夹
程序可以用os.makedirs()函数创建新文件夹（目录）。os.makedirs()将创建所有必要的中间文件夹，目的是确保完整路径名存在。

### os.path模块
os.path模块包含了许多与文件名和文件路径相关的有用函数。

os.path模块的完整文档在Python网站上： [http://docs.python.org/3/library/os.path.html]() 。

### 处理绝对路径和相对路径
os.path模块提供了一些函数，返回一个相对路径的绝对路径，以及检查给定的路径是否为绝对路径。

- 调用os.path.abspath(path)将返回参数的绝对路径的字符串。这是将相对路径转换为绝对路径的简便方法。
- 调用os.path.isabs(path)，如果参数是一个绝对路径，就返回True，如果参数是一个相对路径，就返回False。
- 调用os.path.relpath(path, start)将返回从start路径到path的相对路径的字符串。如果没有提供start，就使用当前工作目录作为开始路径。
- 调用os.path.dirname(path)将返回一个字符串，它包含path参数中最后一个斜杠之前的所有内容。
- 调用os.path.basename(path)将返回一个字符串，它包含path 参数中最后一个斜杠之后的所有内容。
- 调用os.path.split()将返回两个字符串的元组，它们分别是一个路径的目录名称和基本名称。

### 查看文件大小和文件夹内容
os.path模块提供了一些函数，用于查看文件的字节数以及给定文件夹中的文件和子文件夹。
- 调用os.path.getsize(path)将返回path参数中文件的字节数。
- 调用os.listdir(path)将返回文件名字符串的列表，包含path参数中的每个文件（请注意，这个函数在os模块中，而不是os.path）。

### 检查路径有效性
os.path模块提供了一些函数，用于检测给定的路径是否存在，以及它是文件还是文件夹。
- 如果path参数所指的文件或文件夹存在，调用os.path.exists(path)将返回True，否则返回False。
- 如果path参数存在，并且是一个文件，调用os.path.isfile(path)将返回True，否则返回False。
- 如果path参数存在，并且是一个文件夹，调用os.path.isdir(path)将返回True，否则返回False。

## 文件读写过程
“纯文本文件”只包含基本文本字符，不包含字体、大小和颜色信息。带有.txt扩展名的文本文件，以及带有.py扩展名的Python脚本文件，都是纯文本文件的例子。

“二进制文件”是所有其他文件类型，诸如字处理文档、PDF、图像、电子表格和可执行程序。

【本章的内容大部分仅适用于“纯文本文件”。】

在Python中，读写文件有3个步骤：
1. 调用open()函数，返回一个File对象。
2. 调用File对象的read()或write()方法。
3. 调用File对象的close()方法，关闭该文件。

### 用open()函数打开文件
向open()函数传递一个字符串路径，表明希望打开的文件。这既可以是绝对路径，也可以是相对路径。open()函数返回一个File对象。File对象代表计算机中的一个文件，它只是Python中另一种类型的值

这个函数将以读取纯文本文件的模式打开文件，或简称为“读模式”。

当文件以读模式打开时，Python只让你从文件中读取数据，你不能以任何方式写入或修改它。在Python中打开文件时，读模式是默认的模式。

如果你不希望依赖于Python的默认值，也可以明确指明该模式，向open()传入字符串'r'，作为第二个参数。

### 读取文件内容
使用File对象的read()方法，将整个文件的内容读取为一个字符串值。将文件的内容看成是单个大字符串，read()方法就返回保存在该文件中的这个字符串。

使用readlines()方法，从该文件取得一个字符串的列表。列表中的每个字符串就是文本中的每一行。

### 写入文件
打开文件时用读模式，就不能写入文件。需要以“写入纯文本模式”或“添加纯文本模式”打开该文件，或简称为“写模式”和“添加模式”。

写模式将覆写原有的文件，从头开始。将'w'作为第二个参数传递给open()，以写模式打开该文件。

添加模式将在已有文件的末尾添加文本，而不是完全覆写该变量。将'a'作为第二个参数传递给open()，以添加模式打开该文件。

如果传递给 open()的文件名不存在，写模式和添加模式都会创建一个新的空文件。在读取或写入文件后，调用close()方法，然后才能再次打开该文件。

调用write()，并向write()传入字符串参数，将字符串写入文件，并返回写入的字符个数，包括换行符。write()方法不会像print()函数那样，在字符串的末尾自动添加换行字符。必须自己添加该字符。

## 用shelve模块保存变量
利用shelve模块，你可以将Python程序中的变量保存到二进制的shelf文件中。

调用函数shelve.open()并传入一个文件名，然后将返回的值保存在一个变量中。可以对这个变量的shelf值进行修改，就像它是一个字典一样。当你完成时，在这个值上调用close()。

shelf值不必用读模式或写模式打开，因为它们在打开后，既能读又能写。

就像字典一样，shelf值有keys()和values()方法，返回shelf中键和值的类似列表的值。因为这些方法返回类似列表的值，而不是真正的列表，所以应该将它们传递给list()函数，取得列表的形式。

## 用pprint.pformat()函数保存变量
pprint.pformat()函数将返回同样的文本字符串，但不是打印它。这个字符串不仅是易于阅读的格式，同时也是语法上正确的Python代码。

pprint.pformat()函数将提供一个字符串，你可以将它写入.py文件。该文件将成为你自己的模块，如果你需要使用存储在其中的变量，就可以导入它。

由于Python脚本本身也是带有.py文件扩展名的文本文件，所以你的Python程序甚至可以生成其他Python程序。然后可以将这些文件导入到脚本中。

对于大多数应用，利用shelve模块来保存数据，是将变量保存到文件的最佳方式。只有基本数据类型，诸如整型、浮点型、字符串、列表和字典，可以作为简单文本写入一个文件。

# 组织文件
## shutil模块
shutil（或称为shell工具）模块中包含一些函数，让你在Python程序中复制、移动、改名和删除文件。要使用shutil的函数，首先需要import shutil。

### 复制文件和文件夹
调用shutil.copy(source, destination)，将路径source处的文件复制到路径destination处的文件夹（source和destination都是字符串）。

如果destination是一个文件名，它将作为被复制文件的新名字。该函数返回一个字符串，表示被复制文件的路径。

shutil.copytree()将复制整个文件夹，以及它包含的文件夹和文件。调用shutil.copytree(source, destination)，将路径source处的文件夹，包括它的所有文件和子文件夹，复制到路径destination处的文件夹。source和destination参数都是字符串。该函数返回一个字符串，是新复制的文件夹的路径。

### 文件和文件夹的移动与改名
调用shutil.move(source, destination)，将路径source处的文件夹移动到路径destination，并返回新位置的绝对路径的字符串。

如果destination指向一个文件夹，source文件将移动到destination中，并保持原来的文件名。

如果destination路径指定一个文件名，source文件将被移动并改名。

最后，构成目的地的文件夹必须已经存在，否则Python会抛出异常。

【这个鬼方法特性一堆，我这边建议是要用的时候再去好好查一下。】

### 永久删除文件和文件夹
利用os模块中的函数，可以删除一个文件或一个空文件夹。但利用shutil模块，可以删除一个文件夹及其所有的内容。

- 用os.unlink(path)将删除path处的文件。
- 调用os.rmdir(path)将删除path处的文件夹。该文件夹必须为空，其中没有任何文件和文件夹。
- 调用shutil.rmtree(path)将删除path处的文件夹，它包含的所有文件和文件夹都会被删除。

在程序中使用这些函数时要小心！可以第一次运行程序时，注释掉这些调用，并且加上print()调用，显示会被删除的文件。【属于是救命的提醒】

### 用send2trash模块安全地删除
删除文件和文件夹的更好方法，是使用第三方的send2trash模块。

利用send2trash，比Python常规的删除函数要安全得多，因为它会将文件夹和文件发送到计算机的垃圾箱或回收站，而不是永久删除它们。

使用send2trash.send2trash()函数来删除文件和文件夹。

## 遍历目录树
os.walk()函数被传入一个字符串值，即一个文件夹的路径。os.walk()在循环的每次迭代中，返回3个值：
1. 当前文件夹名称的字符串。
2. 当前文件夹中子文件夹的字符串的列表。
3. 当前文件夹中文件的字符串的列表。

所谓当前文件夹，是指for循环当前迭代的文件夹。程序的当前工作目录，不会因为os.walk()而改变。

## 用zipfile模块压缩文件
利用zipfile模块中的函数，Python程序可以创建和打开（或解压）ZIP文件。

### 读取ZIP文件
要读取ZIP文件的内容，首先必须创建一个ZipFile对象（请注意大写首字母Z和F）。

要创建一个ZipFile对象，就调用zipfile.ZipFile()函数，向它传入一个字符串，表示.zip文件的文件名。

ZipFile对象有一个namelist()方法，返回ZIP文件中包含的所有文件和文件夹的字符串的列表。这些字符串可以传递给ZipFile对象的getinfo()方法，返回一个关于特定文件的ZipInfo对象。

ZipFile对象表示整个归档文件，而ZipInfo对象则保存该归档文件中每个文件的有用信息。

### 从ZIP文件中解压缩
ZipFile对象的extractall()方法从ZIP文件中解压缩所有文件和文件夹，放到当前工作目录中。

可以向extractall()传递的一个文件夹名称，它将文件解压缩到那个文件夹，而不是当前工作目录。如果传递给extractall()方法的文件夹不存在，它会被创建。

ZipFile对象的extract()方法从ZIP文件中解压缩单个文件。传递给extract()的字符串，必须匹配namelist()返回的字符串列表中的一个。或者，你可以向extract()传递第二个参数，将文件解压缩到指定的文件夹，而不是当前工作目录。如果第二个参数指定的文件夹不存在，Python就会创建它。extract()的返回值是被压缩后文件的绝对路径。

### 创建和添加到ZIP文件
创建压缩ZIP文件，必须以“写模式”打开ZipFile对象，即传入'w'作为第二个参数（这类似于向open()函数传入'w'，以写模式打开一个文本文件）。

向ZipFile对象的write()方法传入一个路径，Python就会压缩该路径所指的文件，将它加到ZIP文件中。write()方法的第一个参数是一个字符串，代表要添加的文件名。第二个参数是“压缩类型”参数，它告诉计算机使用怎样的算法来压缩文件。可以总是将这个值设置为zipfile.ZIP_DEFLATED（这指定了deflate压缩算法，它对各种类型的数据都很有效）。

就像写入文件一样，写模式将擦除ZIP文件中所有原有的内容。如果只是希望将文件添加到原有的ZIP文件中，就要向zipfile.ZipFile()传入'a'作为第二个参数，以添加模式打开ZIP文件。

# 调试
## 抛出异常
当Python试图执行无效代码时，就会抛出异常。

抛出异常相当于是说：“停止运行这个函数中的代码，将程序执行转到except语句”。抛出异常使用raise语句。在代码中，raise语句包含以下部分：
raise关键字；
- 对Exception函数的调用；
- 传递给Exception函数的字符串，包含有用的出错信息。

通常是调用该函数的代码知道如何处理异常，而不是该函数本身。所以常常会看到raise语句在一个函数中，try和except语句在调用该函数的代码中。使用try和except语句，你可以更优雅地处理错误，而不是让整个程序崩溃。

## 取得反向跟踪的字符串
如果Python遇到错误，它就会生成一些错误信息，称为“反向跟踪”。反向跟踪包含了出错消息、导致该错误的代码行号，以及导致该错误的函数调用的序列。这个序列称为“调用栈”。

在从多个位置调用函数的程序中，调用栈就能帮助你确定哪次调用导致了错误。

只要抛出的异常没有被处理，Python 就会显示反向跟踪。但你也可以调用traceback.format_exc()，得到它的字符串形式。如果你希望得到异常的反向跟踪的信息，但也希望except语句优雅地处理该异常，这个函数就很有用。在调用该函数之前，需要导入Python的traceback模块。

## 断言
“断言”是一个心智正常的检查，确保代码没有做什么明显错误的事情。这些心智正常的检查由assert语句执行。如果检查失败，就会抛出异常。在代码中，assert语句包含以下部分：
- assert关键字；
- 条件（即求值为True或False的表达式）；
- 逗号；
- 当条件为False时显示的字符串。

断言针对的是程序员的错误，而不是用户的错误。对于那些可以恢复的错误（诸如文件没有找到，或用户输入了无效的数据），请抛出异常，而不是用assert语句检测它。

### 禁用断言
在运行Python时传入-O选项，可以禁用断言。如果你已完成了程序的编写和测试，不希望执行心智正常检测，从而减慢程序的速度，这样就很好（尽管大多数断言语句所花的时间，不会让你觉察到速度的差异）。断言是针对开发的，不是针对最终产品。当你将程序交给其他人运行时，它应该没有缺陷，不需要进行心智正常检查。

## 日志
Python的logging模块使得你很容易创建自定义的消息记录。这些日志消息将描述程序执行何时到达日志函数调用，并列出你指定的任何变量当时的值。另一方面，缺失日志信息表明有一部分代码被跳过，从未执行。
### 使用日志模块
> 要启用logging模块，在程序运行时将日志信息显示在屏幕上，请将下面的代码复制到程序顶部（但在Python的#!行之下）：
> 
> import logging
> 
> logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s
> 
> -   %(message)s') 
> 
> 你不需要过于担心它的工作原理，但基本上，当 Python 记录一个事件的日志时，它会创建一个LogRecord对象，保存关于该事件的信息。logging模块的函数让你指定想看到的这个LogRecord对象的细节，以及希望的细节展示方式。

在想打印日志信息时，使用logging.debug() 函数。这个debug() 函数将调用basicConfig()，打印一行信息。这行信息的格式是我们在 basicConfig()函数中指定的，并且包括我们传递给 debug() 的消息。

### 不要用print()调试
日志消息的好处在于，你可以随心所欲地在程序中想加多少就加多少，稍后只要加入一次logging.disable（logging.CRITICAL）调用，就可以禁止日志。

日志消息是给程序员的，不是给用户的。用户不会因为你便于调试，而想看到的字典值的内容。请将日志信息用于类似这样的目的。对于用户希望看到的消息，例如“文件未找到”或者“无效的输入，请输入一个数字”，应该使用print() 调用。我们不希望禁用日志消息之后，让用户看不到有用的信息。

### 日志级别
“日志级别”提供了一种方式，按重要性对日志消息进行分类。5个日志级别如表10-1所示，从最不重要到最重要。利用不同的日志函数，消息可以按某个级别记入日志。

Python中的日志级别表

| 级别 | 日志函数 | 描述 |
|:----:|:----:|:----:|
|   DEBUG   |   logging.debug()   |   最低级别。用于小细节。通常只有在诊断问题时，你才会关心这些消息   |
|   INFO   |   logging.info()   |   用于记录程序中一般事件的信息，或确认一切工作正常   |
|   WARNING   |   logging.warning()   |   用于表示可能的问题，它不会阻止程序的工作，但将来可能会   |
|   ERROR   |   logging.error()   |   用于记录错误，它导致程序做某事失败   |
|   CRITICAL   |   logging.critical()   |   最高级别。用于表示致命的错误，它导致或将要导致程序完全停止工作   |

日志消息作为一个字符串，传递给这些函数。日志级别是一种建议。归根到底，还是由你来决定日志消息属于哪一种类型。

### 禁用日志
只要向logging.disable() 传入一个日志级别，它就会禁止该级别和更低级别的所有日志消息。所以，如果想要禁用所有日志，只要在程序中添加logging. disable（logging.CRITICAL）。

因为logging.disable() 将禁用它之后的所有消息，你可能希望将它添加到程序中接近import logging代码行的位置。这样就很容易找到它，根据需要注释掉它，或取消注释，从而启用或禁用日志消息。

### 将日志记录到文件
logging.basic Config() 函数接受filename关键字参数，日志信息将被保存到filename文件中。

```python
# example
import logging
logging.basicConfig( filename='myProgramLog.txt' , level=logging.DEBUG, format='
%(asctime)s - %(levelname)s - %(message)s')
```

# 从Web抓取信息
几个Web相关模块：
- webbrowser：是Python自带的，打开浏览器获取指定页面。
- requests：从因特网上下载文件和网页。
- Beautiful Soup：解析HTML，即网页编写的格式。
- selenium：启动并控制一个Web浏览器。selenium能够填写表单，并模拟鼠标在这个浏览器中点击。

## webbrowser模块
webbrowser模块的open()函数可以启动一个新浏览器，打开指定的URL。

## 用requests模块从Web下载文件
requests模块让你很容易从Web下载文件，不必担心一些复杂的问题，诸如网络错误、连接问题和数据压缩。

requests模块不是Python自带的，所以必须先安装。
### 用requests.get()函数下载一个网页
requests.get()函数接受一个要下载的URL字符串。通过在requests.get()的返回值上调用type()，它将返回一个Response对象，其中包含了Web服务器对你的请求做出的响应。

通过检查Response对象的status_code属性，可以了解对这个网页的请求是否成功。如果该值等于requests.codes.ok，那么一切都好。【或者读者（我）需要熟悉一下HTTP协议？】

如果请求成功，下载的页面就作为一个字符串，保存在Response对象的text变量中。

### 检查错误
Response对象有一个status_code属性，可以检查它是否等于requests.codes.ok，了解下载是否成功。

检查成功有一种简单的方法，就是在Response对象上调用raise_for_status()方法。如果下载文件出错，这将抛出异常。如果下载成功，就什么也不做。

## 将下载的文件保存到硬盘
可以用标准的open()函数和write()方法，将Web页面保存到硬盘中的一个文件。首先，必须用“写二进制”模式打开该文件，即向函数传入字符串'wb'，作为open()的第二参数，目的是为了保存该文本中的“Unicode编码”。

为了将Web页面写入到一个文件，可以使用for循环和Response对象的iter_content()方法。iter_content()方法在循环的每次迭代中，返回一段内容。每一段都是bytes数据类型，你需要指定一段包含多少字节。10万字节通常是不错的选择，所以将100000作为参数传递给iter_content()。

write()方法返回一个数字，表示写入文件的字节数。

下载并保存到文件的完整过程如下：
1. 调用requests.get()下载该文件。
2. 用'wb'调用open()，以写二进制的方式打开一个新文件。
3. 利用Respose对象的iter_content()方法做循环。
4. 在每次迭代中调用write()，将内容写入该文件。
5. 调用close()关闭该文件。

```python
# example
>>> import requests 
>>> res = requests.get('http://www.gutenberg.org/cache/epub/1112/pg1112.txt') 
>>> res.raise_for_status() 
>>> playFile = open('RomeoAndJuliet.txt', 'wb') 
>>> for chunk in res.iter_content(100000): 
        playFile.write(chunk)
100000
78981
>>>  playFile.close()
```

## HTML
超文本标记语言（HTML）是编写Web页面的格式。

### 快速复习（学习）
HTML文件是一个纯文本文件，带有.html文件扩展名。这种文件中的文本被“标签”环绕，标签是尖括号包围的单词。标签告诉浏览器以怎样的格式显示该页面。一个开始标签和一个结束标签可以包围某段文本，形成一个“元素”。“文本”（或“内部的HTML”）是在开始标签和结束标签之间的内容。

HTML中有许多不同的标签。有一些标签具有额外的特性，在尖括号内以“属性”的方式展现。

### 查看网页的HTML源代码
对于程序要处理的网页，你需要查看它的HTML源代码。要做到这一点，在浏览器的任意网页上点击右键（或在OS X上Ctrl-点击），选择View Source或View page source，查看该页的 HTML 文本（参见图 11-3）。【实际操作因浏览器而异。】

### 打开浏览器的开发者工具
在Windows版的Chrome和IE中，开发者工具已经安装了。可以按下F12，让它们出现（参见图11-4）。再次按下F12，可以让开发者工具消失。在Chrome中，也可以选择View ►Developer ►Developer Tools，调出开发者工具。

> **不要用正则表达式来解析HTML**
> 在一个字符串中定位特定的一段HTML，这似乎很适合使用正则表达式。但是，我建议你不要这么做。HTML 的格式可以有许多不同的方式，并且仍然被认为是有效的HTML，但尝试用正则表达式来捕捉所有这些可能的变化，将非常繁琐，并且容易出错。专门用于解析HTML的模块，诸如Beautiful Soup，将更不容易导致缺陷。在 http://stackoverflow.com/a/1732454/1893164/ ，你会看到更充分的讨论，了解为什么不应该用正则表达式来解析HTML。

### 使用开发者工具来寻找HTML元素
程序利用requests模块下载了一个网页之后，你会得到该页的HTML内容，作为一个字符串值。

在开发者工具中知道了要找的是什么，BeautifulSoup模块就可以帮助你在这个字符串中找到它。

### 用BeautifulSoup模块解析HTML
Beautiful Soup是一个模块，用于从HTML页面中提取信息（用于这个目的时，它比正则表达式好很多）。

这是个第三方模块，请自行搜索安装方式。

### 从HTML创建一个BeautifulSoup对象
bs4.BeautifulSoup()函数调用时需要一个字符串，其中包含将要解析的HTML。bs4.BeautifulSoup()函数返回一个BeautifulSoup对象。

也可以向bs4.BeautifulSoup()传递一个File对象，从硬盘加载一个HTML文件。

### 用select()方法寻找元素
调用method()方法，传入一个字符串作为CSS“选择器”，这样就可以取得Web页面元素。选择器就像正则表达式：它们指定了要寻找的模式。

CSS选择器的例子表

| 传递给 select()方法的选择器 | 将匹配… |
|:----:|:----:|
|   soup.select('div')   |   所有名为< div>的元素   |
|   soup.select('#author')   |   带有id属性为author的元素   |
|   soup.select('.notice')   |   所有使用CSS class属性名为notice的元素   |
|   soup.select('div span')   |   所有在< div>元素之内的< span>元素   |
|   soup.select('div > span')   |   所有直接在< div>元素之内的< span>元素，中间没有其他元素   |
|   soup.select('input[name]')   |   所有名为< input>，并有一个name属性，其值无所谓的元素   |
|   soup.select('input[type="button"]')   |   所有名为< input>，并有一个type属性，其值为button的元素   |

完整地讨论 CSS 选择器的语法请自行搜索。

select()方法将返回一个Tag对象的列表，这是Beautiful Soup表示一个HTML元素的方式。针对BeautifulSoup对象中的HTML的每次匹配，列表中都有一个Tag对象。Tag值可以传递给str()函数，显示它们代表的HTML标签。Tag值也可以有attrs属性，它将该Tag的所有HTML属性作为一个字典。

在Tag对象上调用getText()方法，返回该对象的文本，或内部的HTML。一个Tag对象的文本是在开始和结束标签之间的内容。

将Tag对象传递给str()，这将返回一个字符串，其中包含开始和结束标签，以及它的文本。

### 通过元素的属性获取数据
向Tag对象的get()方法传入一个属性名称的字符串，它将返回该属性的值。

## 用selenium模块控制浏览器
selenium模块让Python直接控制浏览器，实际点击链接，填写登录信息，几乎就像是有一个人类用户在与页面交互。与Requests和Beautiful Soup相比，Selenium允许你用高级得多的方式与网页交互。

### 启动selenium控制的浏览器
导入selenium的模块需要一点技巧。不是import selenium，而是要运行from selenium import webdriver

【以下的内容中打开的浏览器都是火狐，但我不想用这玩意儿，所以有些地方的笔记会显得很怪异。也就是说，我会省略去提到火狐的内容，尽管那和重要的内容有关。】

### 在页面中寻找元素
WebDriver对象有好几种方法，用于在页面中寻找元素。它们被分成findelement和find elements方法。findelement方法返回一个WebElement对象，代表页面中匹配查询的第一个元素。find elements方法返回WebElement_*对象的列表，包含页面中所有匹配的元素。

（表）selenium的WebDriver方法，用于寻找元素

| 方法名 | 返回的WebElement对象/列表 |
|:----:|:----:|
|   browser.find_element_by_class_name(name)   |   使用CSS类name的元素   |
|   browser.find_element_by_css_selector(selector)   |   匹配CSS   selector 的元素   |
|   browser.find_element_by_id(id)    |   匹配  id 属性值的元素   |
|   browser.find_element_by_link_text(text)   |  完全匹配提供的text的< a>元素    |
|   browser.find_element_by_partial_link_text(text)   |   包含提供的text的<a>元素   |
|   browser.find_element_by_name(name)   |  匹配  name 属性值的元素    |
|   browser.find_element_by_tag_name(name)   |   匹配标签 name 的元素 (大小写无关，<a>元素匹配'a'和'A')   |

除了*_by_tag_name()方法，所有方法的参数都是区分大小写的。如果页面上没有元素匹配该方法要查找的元素，selenium模块就会抛出NoSuchElement异常。如果你不希望这个异常让程序崩溃，就在代码中添加try和except语句。

WebElement的属性和方法表

| 属性或方法 | 描述 |
|:----:|:----:|
|   tag_name   |   标签名，例如 'a'表示< a>元素   |
|   get_attribute(name)   |   该元素name属性的值   |
|   text   |   该元素内的文本，例如< span>hello< /span>中的'hello'   |
|   clear()   |   对于文本字段或文本区域元素，清除其中输入的文本   |
|   is_displayed()   |   如果该元素可见，返回True，否则返回False   |
|   is_enabled()   |   对于输入元素，如果该元素启用，返回True，否则返回False()   |
|   is_selected   |   对于复选框或单选框元素，如果该元素被选中，选择True，否则返回False   |
|   location   |   一个字典，包含键'x'和'y'，表示该元素在页面上的位置    |

### 点击页面
findelement和find elements方法返回的WebElement对象有一个click()方法，模拟鼠标在该元素上点击。这个方法可以用于链接跳转，选择单选按钮，点击提交按钮，或者触发该元素被鼠标点击时发生的任何事情。

### 填写并提交表单
向Web页面的文本字段发送击键，只要找到那个文本字段的< input>或< textarea>元素，然后调用send_keys()方法。

在任何元素上调用submit()方法，都等同于点击该元素所在表单的Submit按钮（你可以很容易地调用emailElem.submit()，代码所做的事情一样）。

### 发送特殊键
selenium有一个模块，针对不能用字符串值输入的键盘击键。它的功能非常类似于转义字符。这些值保存在selenium.webdriver.common.keys模块的属性中。由于这个模块名非常长，所以在程序顶部运行from selenium.webdriver. common.keys import Keys就比较容易。如果这么做，原来需要写from selenium. webdriver.common.keys的地方，就只要写Keys。

selenium.webdriver.common.keys模块中常用的变量

| 属性 | 含义 |
|:----:|:----:|
|   Keys.DOWN, Keys.UP, Keys.LEFT,Keys.RIGHT   |   键盘箭头键   |
|   Keys.ENTER, Keys.RETURN   |   回车和换行键   |
|   Keys.HOME, Keys.END,Keys.PAGE_DOWN,Keys.PAGE_UP   |   Home键、End键、PageUp键和Page Down键    |
|   Keys.ESCAPE,Keys.BACK_SPACE,Keys.DELETE   |   Esc、Backspace和字母键   |
|   Keys.F1,Keys.F2, . . . , Keys.F12   |   键盘顶部的F1到F12键   |
|   Keys.TAB   |   Tab键   |

< html>标签是HTML文件中的基本标签：HTML文件的完整内容包含在< html>和< /html>标签之内。调用browser.find_element_by_tag_name('html')是像一般Web页面发送按键的好地方。当你滚动到该页的底部，新的内容就会加载，这可能会有用。

### 点击浏览器按钮
利用以下的方法，selenium也可以模拟点击各种浏览器按钮：
1. browser.back()点击“返回”按钮。
2. browser.forward()点击“前进”按钮。
3. browser.refresh()点击“刷新”按钮。
4. browser.quit()点击“关闭窗口”按钮。

# 处理Excel电子表格
openpyxl模块让Python程序能读取和修改Excel电子表格文件。

LibreOffice Calc和OpenOffice Calc都能处理Excel的电子表格文件格式，这意味着 openpyxl 模块也能处理来自这些应用程序的电子表格。

Python没有自带openpyxl，所以必须安装。

## Excel文档
一个Excel电子表格文档称为一个工作簿。一个工作簿保存在扩展名为.xlsx的文件中。每个工作簿可以包含多个表（也称为工作表）。用户当前查看的表（或关闭Excel前最后查看的表），称为活动表。

每个表都有一些列（地址是从A开始的字母）和一些行（地址是从1开始的数字）。在特定行和列的方格称为单元格。每个单元格都包含一个数字或文本值。单元格形成的网格和数据构成了表。

## 读取Excel文档
### 用openpyxl模块打开Excel文档
openpyxl.load_workbook()函数接受文件名，返回一个workbook数据类型的值。这个workbook对象代表这个Excel文件，有点类似File对象代表一个打开的文本文件。

### 从工作簿中取得工作表
调用get_sheet_names()方法可以取得工作簿中所有表名的列表。

每个表由一个Worksheet对象表示，可以通过向工作簿方法get_sheet_by_name()传递表名字符串获得。最后，可以调用Workbook对象的get_active_sheet()方法，取得工作簿的活动表。活动表是工作簿在Excel中打开时出现的工作表。在取得Worksheet对象后，可以通过title属性取得它的名称。

### 从表中取得单元格
有了Worksheet对象后，就可以按名字访问Cell对象。Cell对象有一个value属性，不出意外，它包含这个单元格中保存的值。Cell对象也有row、column和coordinate属性，提供该单元格的位置信息。

用字母来指定列，这在程序中可能有点奇怪，特别是在Z列之后，列开时使用两个字母：AA、AB、AC等。作为替代，在调用表的cell()方法时，可以传入整数作为row和column关键字参数，也可以得到一个单元格。

可以通过Worksheet对象的get_highest_row()和get_highest_column()方法，确定表的大小。get_highest_column()方法返回一个整数，而不是Excel中出现的字母。

### 列字母和数字之间的转换
要从字母转换到数字，就调用openpyxl.cell.column_index_from_string()函数。要从数字转换到字母，就调用openpyxl.cell.get_column_letter()函数。

函数column_index_string()做的事情相反：传入一列的字母名称，它告诉你该列的数字是什么。要使用这些函数，不必加载一个工作簿。

如果你愿意，可以加载一个工作簿，取得Worksheet对象，并调用Worksheet对象的方法，如get_highest_column()，来取得一个整数。然后，将该整数传递给get_column_letter()。

### 从表中取得行和列
可以将Worksheet对象切片，取得电子表格中一行、一列或一个矩形区域中的所有Cell对象。然后可以循环遍历这个切片中的所有单元格。

### 工作簿、工作表、单元格
作为快速复习，下面是从电子表格文件中读取单元格涉及的所有函数、方法和数据类型。

1. 导入openpyxl模块。
2. 调用openpyxl.load_workbook()函数。
3. 取得Workbook对象。
4. 调用get_active_sheet()或get_sheet_by_name()工作簿方法。
5. 取得Worksheet对象。
6. 使用索引或工作表的cell()方法，带上row和column关键字参数。
7. 取得Cell对象。
8. 读取Cell对象的value属性。

## 写入Excel文档
OpenPyXL也提供了一些方法写入数据，这意味着你的程序可以创建和编辑电子表格文件。

### 创建并保存Excel文档
调用openpyxl.Workbook()函数，创建一个新的空Workbook对象。

工作簿将从一个工作表开始，名为Sheet。你可以将新的字符串保存在它的title属性中，从而改变工作表的名字。

当修改Workbook对象或它的工作表和单元格时，电子表格文件不会保存，除非你调用save()工作簿方法。

### 创建和删除工作表
利用create_sheet() and remove_sheet()方法，可以在工作簿中添加或删除工作表。

create_sheet()方法返回一个新的Worksheet对象，名为SheetX，它默认是工作簿的最后一个工作表。或者，可以利用index和title关键字参数，指定新工作表的索引或名称。

remove_sheet()方法接受一个Worksheet对象作为其参数，而不是工作表名称的字符串。如果你只知道要删除的工作表的名称，就调用get_sheet_by_name()，将它的返回值传入remove_sheet()。

### 将值写入单元格
将值写入单元格，很像将值写入字典中的键。

```python
# example
>>> import openpyxl 
>>> wb = openpyxl.Workbook() 
>>> sheet = wb.get_sheet_by_name('Sheet') 
>>> sheet['A1'] = 'Hello world!' 
>>> sheet['A1'].value 
'Hello world!'
```

## 设置单元格的字体风格
## Font对象
Font对象的style属性影响文本在单元格中的显示方式。要设置字体风格属性，就向Font()函数传入关键字参数。

Font style属性的关键字参数

| 关键字参数 | 数据类型 | 描述 |
|:----:|:----:|:----:|
|   name   |   字符串   |   字体名称，诸如'Calibri' 或'Times New Roman'   |
|   size   |   整型   |   大小点数   |
|   bold   |   布尔型   |   True表示粗体   |
|   italic   |   布尔型   |   True表示斜体   |

可以调用Font()来创建一个Font对象，并将这个Font对象保存在一个变量中。然后将它传递给Style()，得到的Style对象保存在一个变量中，并将该变量赋给Cell对象的style属性。

## 公式
公式以一个等号开始，可以配置单元格，让它包含通过其他单元格计算得到的值。

## 调整行和列